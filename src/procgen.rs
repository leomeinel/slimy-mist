/*
 * File: procgen.rs
 * Author: Leopold Johannes Meinel (leo@meinel.dev)
 * -----
 * Copyright (c) 2025 Leopold Johannes Meinel & contributors
 * SPDX ID: Apache-2.0
 * URL: https://www.apache.org/licenses/LICENSE-2.0
 */

pub(crate) mod chunks;
pub(crate) mod navigation;
pub(crate) mod spawn;

use std::marker::PhantomData;

use bevy::{
    platform::collections::{HashMap, HashSet},
    prelude::*,
    reflect::Reflectable,
};
use bevy_prng::WyRand;
use bevy_rand::{global::GlobalRng, traits::ForkableSeed as _};

use crate::{AppSystems, CanvasCamera, logging::error::ERR_LOADING_TILE_DATA};

pub(super) fn plugin(app: &mut App) {
    // Setup timer
    app.insert_resource(ProcGenTimer::default());
    app.add_systems(Update, tick_procgen_timer.in_set(AppSystems::TickTimers));

    // Child plugins
    app.add_plugins(navigation::plugin);

    // Add rng for procedural generation
    app.add_systems(Startup, setup_rng);
}

/// Interval for procedural generation
pub(crate) const PROCGEN_INTERVAL: f32 = 1.;

/// Size of a single chunk
pub(crate) const CHUNK_SIZE: UVec2 = UVec2 { x: 16, y: 16 };

/// Maximum distance for procedural generation
pub(crate) const PROCGEN_DISTANCE: i32 = 2;

/// Applies to anything that is generated by procgen
pub(crate) trait ProcGenerated
where
    Self: Component + Default + Reflectable,
{
}

/// Controller that maps entities to their positions
///
/// We have to store entities since this also handles moving entities.
///
/// ## Traits
///
/// - `T` must implement [`ProcGenerated`] and is used as any procedurally generated item.
#[derive(Default, Debug, Resource)]
pub(crate) struct ProcGenController<T>
where
    T: ProcGenerated,
{
    pub(crate) positions: HashMap<Entity, IVec2>,
    _phantom: PhantomData<T>,
}

/// Timer that tracks procedural generation
#[derive(Resource, Debug, Clone, PartialEq, Reflect)]
#[reflect(Resource)]
pub(crate) struct ProcGenTimer(Timer);
impl Default for ProcGenTimer {
    fn default() -> Self {
        Self(Timer::from_seconds(PROCGEN_INTERVAL, TimerMode::Repeating))
    }
}

/// Animation data deserialized from a ron file as a generic
///
/// ## Traits
///
/// - `T` must implement [`ProcGenerated`] and is used as a level's procedurally generated item.
#[derive(serde::Deserialize, Asset, TypePath, Default)]
pub(crate) struct TileData<T>
where
    T: ProcGenerated,
{
    pub(crate) tile_width: f32,
    pub(crate) tile_height: f32,
    #[serde(default)]
    full_dirt_tiles: Option<HashSet<UVec2>>,
    #[serde(default)]
    full_grass_tiles: Option<HashSet<UVec2>>,
    #[serde(default)]
    corner_outer_grass_to_dirt_tiles: Option<HashSet<UVec2>>,
    #[serde(default)]
    corner_outer_dirt_to_grass_tiles: Option<HashSet<UVec2>>,
    #[serde(default)]
    side_dirt_and_grass_tiles: Option<HashSet<UVec2>>,
    #[serde(default)]
    diag_stripe_grass_in_dirt_tiles: Option<HashSet<UVec2>>,
    #[serde(skip)]
    _phantom: PhantomData<T>,
}
impl<T> TileData<T>
where
    T: ProcGenerated,
{
    fn get_tiles(
        &self,
    ) -> Option<(
        HashSet<UVec2>,
        HashSet<UVec2>,
        HashSet<UVec2>,
        HashSet<UVec2>,
        HashSet<UVec2>,
        HashSet<UVec2>,
    )> {
        Some((
            self.full_dirt_tiles.as_ref().cloned()?,
            self.full_grass_tiles.as_ref().cloned()?,
            self.corner_outer_grass_to_dirt_tiles.as_ref().cloned()?,
            self.corner_outer_dirt_to_grass_tiles.as_ref().cloned()?,
            self.side_dirt_and_grass_tiles.as_ref().cloned()?,
            self.diag_stripe_grass_in_dirt_tiles.as_ref().cloned()?,
        ))
    }
}

/// Handle for [`TileData`] as a generic
///
/// ## Traits
///
/// - `T` must implement [`ProcGenerated`] and is used as a level's procedurally generated item.
#[derive(Resource)]
pub(crate) struct TileHandle<T>(pub(crate) Handle<TileData<T>>)
where
    T: ProcGenerated;

/// Rng for procedural generation
#[derive(Component)]
pub(crate) struct ProcGenRng;

/// Despawn procedurally generated entities outside of [`PROCGEN_DISTANCE`] and remove entries in controller
///
/// ## Traits
///
/// - `T` must implement [`ProcGenerated`] and is used as the procedurally generated item associated with a [`ProcGenController<T>`].
/// - `A` must implement [`ProcGenerated`] and is used as a level's procedurally generated item.
pub(crate) fn despawn_procgen<T, A>(
    camera: Single<(&Transform, Ref<Transform>), (With<CanvasCamera>, Without<T>)>,
    query: Query<(Entity, &Transform), (With<T>, Without<CanvasCamera>)>,
    mut commands: Commands,
    mut controller: ResMut<ProcGenController<T>>,
    data: Res<Assets<TileData<A>>>,
    handle: Res<TileHandle<A>>,
    timer: Res<ProcGenTimer>,
) where
    T: ProcGenerated,
    A: ProcGenerated,
{
    // Return if timer has not finished
    if !timer.0.just_finished() {
        return;
    }

    let (camera, ref_camera) = camera.into_inner();

    // Return if camera transform has not changed
    if !ref_camera.is_changed() {
        return;
    }

    // Get data from `TileData` with `TileHandle`
    let data = data.get(handle.0.id()).expect(ERR_LOADING_TILE_DATA);
    let tile_size = Vec2::new(data.tile_height, data.tile_width);

    // Despawn entities outside of `DESPAWN_RANGE`
    for (entity, transform) in query.iter() {
        let chunk_size_px = CHUNK_SIZE.as_vec2() * tile_size;
        let camera_chunk_pos = (camera.translation.xy() / chunk_size_px).floor().as_ivec2();
        let chunk_pos = (transform.translation.xy() / chunk_size_px)
            .floor()
            .as_ivec2();

        // NOTE: We are using `chebyshev_distance` because we are spawning in a square.
        if camera_chunk_pos.chebyshev_distance(chunk_pos) > PROCGEN_DISTANCE as u32 {
            controller.positions.remove(&entity);
            commands.entity(entity).despawn();
        }
    }
}

/// Clear [`ProcGenController<T>`]
///
/// ## Traits
///
/// - `T` must implement [`ProcGenerated`] and is used as the procedurally generated item associated with a [`ProcGenController<T>`].
pub(crate) fn clear_procgen_controller<T>(mut controller: ResMut<ProcGenController<T>>)
where
    T: ProcGenerated,
{
    controller.positions.clear();
}

/// Spawn [`ProcGenRng`] by forking [`GlobalRng`]
fn setup_rng(mut global: Single<&mut WyRand, With<GlobalRng>>, mut commands: Commands) {
    commands.spawn((ProcGenRng, global.fork_seed()));
}

/// Tick timer for procedural generation
fn tick_procgen_timer(mut timer: ResMut<ProcGenTimer>, time: Res<Time>) {
    timer.0.tick(time.delta());
}
