/*
 * File: procgen.rs
 * Author: Leopold Johannes Meinel (leo@meinel.dev)
 * -----
 * Copyright (c) 2026 Leopold Johannes Meinel & contributors
 * SPDX ID: Apache-2.0
 * URL: https://www.apache.org/licenses/LICENSE-2.0
 */

pub(crate) mod chunks;
pub(crate) mod navmesh;
pub(crate) mod spawn;

use std::marker::PhantomData;

use bevy::{
    platform::collections::{HashMap, HashSet},
    prelude::*,
    reflect::Reflectable,
};
use bevy_prng::WyRand;
use bevy_rand::{global::GlobalRng, traits::ForkableSeed as _};

use crate::{
    camera::CanvasCamera,
    characters::npc::Slime,
    levels::overworld::{Overworld, OverworldAssets, OverworldProcGen},
    logging::error::{ERR_INVALID_MINIMUM_CHUNK_POS, ERR_LOADING_TILE_DATA},
    procgen::{chunks::spawn_chunks, navmesh::move_navmesh, spawn::spawn_characters},
    screens::Screen,
};

pub(super) fn plugin(app: &mut App) {
    // Initialize proc gen state
    app.init_state::<ProcGenState>();
    app.init_state::<ProcGenInit>();

    // Child plugins
    app.add_plugins(navmesh::plugin);

    // Add rng for procedural generation
    app.add_systems(Startup, setup_rng);

    // Despawn procgen
    app.add_systems(
        Update,
        ((
            despawn_procgen::<Slime, OverworldProcGen, false>,
            despawn_procgen::<OverworldProcGen, OverworldProcGen, true>,
        )
            .run_if(in_state(ProcGenState::Despawn)),)
            .run_if(in_state(Screen::Gameplay)),
    );
    // Spawn procgen
    app.add_systems(
        OnEnter(ProcGenState::Spawn),
        (
            spawn_chunks::<OverworldProcGen, OverworldAssets, Overworld>,
            spawn_characters::<Slime, OverworldProcGen, Overworld>,
        )
            .run_if(in_state(Screen::Gameplay)),
    );
    // Move navmesh
    app.add_systems(
        OnEnter(ProcGenState::MoveNavMesh),
        move_navmesh::<OverworldProcGen>.run_if(in_state(Screen::Gameplay)),
    );

    // Reset controllers and states when exiting gameplay
    app.add_systems(
        OnExit(Screen::Gameplay),
        (
            clear_procgen_controller::<OverworldProcGen>,
            clear_procgen_controller::<Slime>,
            reset_procgen_state,
            reset_procgen_init,
        ),
    );
}

/// Size of a single chunk
pub(crate) const CHUNK_SIZE: UVec2 = UVec2 { x: 16, y: 16 };

/// Maximum distance for procedural generation
pub(crate) const PROCGEN_DISTANCE: i32 = 2;

/// Tracks the current proc gen task
#[derive(States, Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub(crate) enum ProcGenState {
    #[default]
    Despawn,
    Spawn,
    MoveNavMesh,
}

/// Tracks the proc gen has been initialized fully at least once
#[derive(States, Copy, Clone, Eq, PartialEq, Hash, Debug, Default)]
pub(crate) struct ProcGenInit(pub(crate) bool);

/// Applies to anything that is generated by procgen
pub(crate) trait ProcGenerated
where
    Self: Component + Default + Reflectable,
{
}

/// Controller that maps entities to their positions
///
/// We have to store entities since this also handles moving entities.
///
/// ## Traits
///
/// - `T` must implement [`ProcGenerated`] and is used as any procedurally generated item.
#[derive(Default, Debug, Resource)]
pub(crate) struct ProcGenController<T>
where
    T: ProcGenerated,
{
    pub(crate) chunk_positions: HashMap<Entity, IVec2>,
    pub(crate) camera_chunk_pos: IVec2,
    _phantom: PhantomData<T>,
}
impl<T> ProcGenController<T>
where
    T: ProcGenerated,
{
    /// Minimum chunk position stored in [`ProcGenController`]
    pub(crate) fn min_chunk_pos(&self) -> &IVec2 {
        self.chunk_positions
            .values()
            .min_by_key(|pos| (pos.x, pos.y))
            .expect(ERR_INVALID_MINIMUM_CHUNK_POS)
    }
}

/// Animation data deserialized from a ron file as a generic
///
/// ## Traits
///
/// - `T` must implement [`ProcGenerated`] and is used as a level's procedurally generated item.
#[derive(serde::Deserialize, Asset, TypePath, Default)]
pub(crate) struct TileData<T>
where
    T: ProcGenerated,
{
    pub(crate) tile_size: f32,
    #[serde(default)]
    full_dirt_tiles: Option<HashSet<UVec2>>,
    #[serde(default)]
    full_grass_tiles: Option<HashSet<UVec2>>,
    #[serde(default)]
    corner_outer_grass_to_dirt_tiles: Option<HashSet<UVec2>>,
    #[serde(default)]
    corner_outer_dirt_to_grass_tiles: Option<HashSet<UVec2>>,
    #[serde(default)]
    side_dirt_and_grass_tiles: Option<HashSet<UVec2>>,
    #[serde(default)]
    diag_stripe_grass_in_dirt_tiles: Option<HashSet<UVec2>>,
    #[serde(skip)]
    _phantom: PhantomData<T>,
}
impl<T> TileData<T>
where
    T: ProcGenerated,
{
    fn get_tiles(
        &self,
    ) -> Option<(
        HashSet<UVec2>,
        HashSet<UVec2>,
        HashSet<UVec2>,
        HashSet<UVec2>,
        HashSet<UVec2>,
        HashSet<UVec2>,
    )> {
        Some((
            self.full_dirt_tiles.as_ref().cloned()?,
            self.full_grass_tiles.as_ref().cloned()?,
            self.corner_outer_grass_to_dirt_tiles.as_ref().cloned()?,
            self.corner_outer_dirt_to_grass_tiles.as_ref().cloned()?,
            self.side_dirt_and_grass_tiles.as_ref().cloned()?,
            self.diag_stripe_grass_in_dirt_tiles.as_ref().cloned()?,
        ))
    }
}

/// Handle for [`TileData`] as a generic
///
/// ## Traits
///
/// - `T` must implement [`ProcGenerated`] and is used as a level's procedurally generated item.
#[derive(Resource)]
pub(crate) struct TileHandle<T>(pub(crate) Handle<TileData<T>>)
where
    T: ProcGenerated;

/// Rng for procedural generation
#[derive(Component)]
pub(crate) struct ProcGenRng;

/// Despawn procedurally generated entities outside of [`PROCGEN_DISTANCE`] and remove entries in controller
///
/// ## Traits
///
/// - `T` must implement [`ProcGenerated`] and is used as the procedurally generated item associated with a [`ProcGenController<T>`].
/// - `A` must implement [`ProcGenerated`] and is used as a level's procedurally generated item.
pub(crate) fn despawn_procgen<T, A, const PROCEED: bool>(
    camera: Single<&Transform, (Changed<Transform>, With<CanvasCamera>, Without<T>)>,
    query: Query<(Entity, &Transform), (With<T>, Without<CanvasCamera>)>,
    mut commands: Commands,
    mut controller: ResMut<ProcGenController<T>>,
    mut next_state: ResMut<NextState<ProcGenState>>,
    data: Res<Assets<TileData<A>>>,
    handle: Res<TileHandle<A>>,
    mut chunk_size_px: Local<Option<Vec2>>,
    mut tile_size: Local<Option<f32>>,
) where
    T: ProcGenerated,
    A: ProcGenerated,
{
    // Init local values
    let tile_size = tile_size.unwrap_or_else(|| {
        let data = data.get(handle.0.id()).expect(ERR_LOADING_TILE_DATA);
        let value = data.tile_size;
        *tile_size = Some(value);
        value
    });
    let chunk_size_px = chunk_size_px.unwrap_or_else(|| {
        let value = CHUNK_SIZE.as_vec2() * tile_size;
        *chunk_size_px = Some(value);
        value
    });

    controller.camera_chunk_pos = (camera.translation.xy() / chunk_size_px).floor().as_ivec2();

    let mut despawned = false;
    // Despawn entities outside of `DESPAWN_RANGE`
    for (entity, transform) in query {
        let chunk_pos = (transform.translation.xy() / chunk_size_px)
            .floor()
            .as_ivec2();

        // NOTE: We are using `chebyshev_distance` because we are spawning in a square.
        if controller.camera_chunk_pos.chebyshev_distance(chunk_pos) > PROCGEN_DISTANCE as u32 {
            controller.chunk_positions.remove(&entity);
            commands.entity(entity).despawn();
            despawned = true;
        }
    }

    // Transition state if required
    if PROCEED && (despawned || query.is_empty()) {
        next_state.set(ProcGenState::Spawn);
    }
}

/// Clear [`ProcGenController<T>`]
///
/// ## Traits
///
/// - `T` must implement [`ProcGenerated`] and is used as the procedurally generated item associated with a [`ProcGenController<T>`].
pub(crate) fn clear_procgen_controller<T>(mut controller: ResMut<ProcGenController<T>>)
where
    T: ProcGenerated,
{
    controller.chunk_positions.clear();
}

/// Spawn [`ProcGenRng`] by forking [`GlobalRng`]
fn setup_rng(mut global: Single<&mut WyRand, With<GlobalRng>>, mut commands: Commands) {
    commands.spawn((ProcGenRng, global.fork_seed()));
}

/// Reset [`ProcGenState`]
fn reset_procgen_state(mut next_state: ResMut<NextState<ProcGenState>>) {
    next_state.set(ProcGenState::default());
}

/// Reset [`ProcGenInit`]
fn reset_procgen_init(mut next_state: ResMut<NextState<ProcGenInit>>) {
    next_state.set(ProcGenInit::default());
}
